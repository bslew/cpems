/*!
* \file Mscsgrid.h - provides generation of various grids from mscsMap class
*
*  Created on: May 18, 2010
*      Author: blew
*/



#ifndef MSCS_GRID_H
#define MSCS_GRID_H

/* **************************************************************************************************** */
/* INCLUDES */
/* **************************************************************************************************** */


/* STANDALONE HEADERS */
#include "Mscs-map.h"

/* INTERDEPENDENT HEADERS */

/* FORWARD DECLARATIONS */

/* USING NAMESPACES (only for inside-header files implementations) */


/* **************************************************************************************************** */
/* CLASS DECLARATION */
/* **************************************************************************************************** */
/*!
\class mscsGrid
\brief Encapsulates generation of equally spaced longitudal and equally spaced latitudal (or gaussian) grids.
\details

	For an input mscsMap object with initiated coordinates, and *temperature*
	this class can generate an equally spaced grid (or gaussian grid) to be subsequently used with various spherepack routines
	such as differential calculus or spherical harmomic and spin harmonic transformations.

	Currently only the full sky maps are correctly supported

	IMPORTANT: Currently only the equally spaced grids are supported. If you want to extend that, then
	among others method getVal needs to be updated

\date created: May 18, 2010, 10:34:56 AM
\author Bartosz Lew
*/
class mscsGrid : public mscsObject {


	/* ---------------------------------------------------------------------------------------------------- */
	/* CLASS PUBLIC MEMBERS */
	/* ---------------------------------------------------------------------------------------------------- */
	public:

		typedef enum { grid_ESLonLat, grid_ESLon, grid_ESLat, grid_ESLonGaussianLat } gridType_t;

		/* ------------- */
		/* CLASS FRIENDS */
		/* ------------- */


		/* ---------------------------- */
		/* CONSTRUCTORS AND DESTRUCTORS */
		/* ---------------------------- */
		mscsGrid(const string name="", cpeds_VerbosityLevel verbosity=CPEDS_defaultVerbosityLevel);
		~mscsGrid();

		mscsGrid(mscsMap* map, const string name="", cpeds_VerbosityLevel verbosity=CPEDS_defaultVerbosityLevel);
		/* ---------------------------- */
		/* PUBLIC METHODS */
		/* ---------------------------- */

		/*!
		\brief generates grid using the map indicated by the pointer given to the constructor
		\details
		@param g - defines the type of grid to be generated
		@param Nth - number of equally spaced points in co-latitude
		@param Nphi - number of equally spaced points in longitude
		@return matrix with the input field
		If you choose gaussian grid then Nth parameter might be omitted or set to zero.

		\date May 18, 2010, 10:54:46 AM
		\author Bartosz Lew
		*/
		const matrix<double>& makeGrid(gridType_t g, long Nphi, long Nth=0);

		/*!
		\brief generates grid using the map indicated by the pointer given to the constructor
		\details
		@param g - defines the type of grid to be generated
		@param dth - separation of equally spaced points in co-latitude
		@param dphi - separation of equally spaced points in longitude
		@return matrix with the input field

		If you choose gaussian grid then Nth parameter might be omited or set to zero.

		The grid is generated by interpolating each ring of co-latitude pixels from the input map at the following longitudes:\n
		phi_i = twoPI/Nphi * i, where i = 0,..Nphi-1\n
		and at the following co-latitudes\n
		th_j = twoPI/Nth * n, where j = 0,..Nth-1\n

		\warning Generation of gaussian grids is not yet implemented
		\date May 18, 2010, 10:54:46 AM
		\author Bartosz Lew
		*/
		const matrix<double>& makeGrid(gridType_t g, double dphi, double dth=0);

		//! return the projected grid;
		matrix<double>& field() { return grid_; }
		//! returns a list of co-latitude values upon which the grid is defined
		cpedsList<double> thVals() const { return thVals_; }
		//! returns a list of longitude values upon which the grid is defined
		cpedsList<double> phiVals() const { return phiVals_; }

		/*!
			\brief returns scalar value stored in the grid at cell corresponding to direction (th,phi)
			\details
			@param th - co-latitude [rad]
			@param phi - latitude [rad]
			@param check - true: the input directions will be check against validity first, false: th,phi are not checked for validity
			@return value in the grid at given direction

			\date May 21, 2010, 1:05:47 PM
		*/
		double getVal(double th, double phi, bool check=true);

		/*!
			\brief returns a new mscsMap temperature map with projected field on it
			\details
			@param nside - nside of the new map

			This method uses simple closest match method to populate the output map.
			This method will necessarily lead to lose of power in the output map as compared to the soruce map

			\date May 21, 2010, 1:10:48 PM
		*/
		mscsMap toMap(long nside);


		/*!
			\brief returns a new mscsMap temperature map with projected field on it
			\details

			This method uses linear extrapolations to recover the map values at the original directions.
			This method theoretically should reproduce exactly the same map as the source map without any lose of the power.

			THIS IS NOT FINISHED

			\date May 21, 2010, 1:58:02 PM
		*/
		mscsMap makeMap();


		/* ---------------------------------------------------------------------------------------------------- */
		/* CLASS PROTECTED MEMBERS */
		/* ---------------------------------------------------------------------------------------------------- */
	protected:


		/* ---------------------------- */
		/* PROTECTED METHODS */
		/* ---------------------------- */


		/* ---------------------------- */
		/* PROTECTED STRUCTURES */
		/* ---------------------------- */
		matrix<double> grid_;
		bool equalySpacedLongitude;
		bool equalySpacedLatitude;
		cpedsList<double> thVals_;
		cpedsList<double> phiVals_;
		mscsMap* srcMap;
		gridType_t gridType;
		long Nphi_,Nth_;
		double dphi_,dth_;

		/* ---------------------------------------------------------------------------------------------------- */
		/* CLASS PRIVATE MEMBERS */
		/* ---------------------------------------------------------------------------------------------------- */
	private:


		/* ---------------------------- */
		/* PRIVATE METHODS */
		/* ---------------------------- */
		const matrix<double>& grid();

		/* ---------------------------- */
		/* PRIVATE STRUCTURES */
		/* ---------------------------- */


};
#endif /* MSCS_GRID_H */




#ifndef MSCSGRID_H_
#define MSCSGRID_H_


#endif /* MSCSGRID_H_ */
